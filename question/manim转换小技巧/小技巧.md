# 小技巧

这部分内容放在问题目录下面不太合适,但也不至于新建一个文件夹整理这些,就不如放在这里简短一谈.

在场景中,提前放入对象(self.add()),不一定是当前形状,如果后面还有其它操作,即使没有再添加,仍会改变,这是manim本身的一个设计.

大部分情况下都没有问题,但是在做一些算法转换等动画时,会产生影响.因为无论我们对内部对象如何操作,总会显示最后一次操作的形状.

那怎么办呢?有两种方案.

第一种是通过self.save_state,保留下来副本(saved_state),外加become()+move_to()来模拟内部的变化.这样其实还是根据副本变化的(copy())

第二种则是投机取巧,也就是我说的小技巧.应用这个技巧的点,是当我们对对象A做完一次动画后,显示地将它从场景中移除,并且删除这个对象,
当前这一帧,以及之前对A产生好了的动画,并不会有任何影响.操作是self.remove(A), del A.这是基本原理.根据这个点,我们可以显示地将VGroup()
移除场景,并且显式地删除这个抽象数组对象.然后根据转换后的数组,再去创建一个新的抽象数组对象,重新转换.第二种的方法,十分浪费时间,不如上
一种好.

总之,场景中的任何操作,永远不会影响子对象的排列顺序. 不过可以通过become,来抽象转化,后续的move_to,仍只是改变场景中的样式,排列层级不会变化.
