@startuml 方法二设计
class S as "SqList"{
    ==属性==
    + size: int
    + sqlist: list
    ==方法==
    (这里先不涉及,后续
    需要的时候再来写因
    为不一定非得全都原
    原本本地存在,有需
    要的时候再来设计就好)
    + update_grps(scene, grps)
}

class p as "目的"{
    ====
    定位没有搞清啊,这里重申一下
    目的/作用是什么.
    ====
    这个类,是为了同步更新VGroup
    中SingleNode的排列方式.manim
    中,self.add()总会根据最后一次
    操作而显示,前面无论多少次变化,
    都起不到作用,而这么类,就是为了
    解决这种情况的.
    ====
    这个类中,有和VGroup相同的数据,
    会同步变化.最后的作用是,返回
    算法操作后的VGroup.注意,这很关键,
    因为,这里并不是生成动画的.刚才想
    了,python中列表有insert,可是如何
    产生动画呢?不用关心,因为这里只是
    返回insert后的VGroup,仅此而已.
    ====
    所以,在对应的类中,会对初始VGroup
    进行算法动画,当进行第一步后,由于
    VGroup无法同步更新而受限,此时可以
    选择这个类,将VGroup更新,而后再进行
    接下来的动画.
    ====
    可能还会考虑,线性表/链表/队列/栈等,
    操纵方式都不一样啊,不具有一般性.这
    是必须的,因为前面的数据结构都是具有
    自己的特性的,相同操作,对应做法肯定
    不相同.我们只需要考虑,操作后的VGroup
    对其后续动画生成是否有帮助即可,并不
    一定非得用这种方式生成.
    ====
    那这么来看,方法一二应该是共存的.甚至可
    以方法二作为父类,方法一继承方法二,也是
    可以的.这种思想不错.那么就先这么干吧.
}
class C as "设计"{
    ====
    列表的动态属性,可以
    很好的添加SingleNode
    对象.所以一开始我们就
    按照一般传统的数据结构
    设计方案设计就好.不过
    最后需要提供个接口,
    专门用于修改Manim中容器
    对象排列方式.大致思想是,
    传入VGroup,scene,清空
    当前组,将容器内当下列表
    对象copy给组,就可以了.
    因为我们总是要清空scene,
    所以需要注意最后时刻场景
    中对象摆列方式,可能需要
    添加系列判断方式.
}

@enduml


